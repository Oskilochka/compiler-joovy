from lexer.lexer import start as lex_start
from lexer import globals as g

# Global variables for CLR translator
tableOfSymb = {}           # Symbol table from lexer
numRow = 0                 # Current record number
len_tableOfSymb = 0        # Total records
cilCode = []               # Generated CIL code
localVars = set()          # Set of local variables
labelCounter = 0           # Counter for generating labels


# ========== HELPER FUNCTIONS ==========

def getSymb():
    """Gets current entry from symbol table"""
    global numRow, tableOfSymb
    if numRow <= len_tableOfSymb:
        numLine, lexeme, token, _ = tableOfSymb[numRow]
        return numLine, lexeme, token
    return None, None, None


def nextSymb():
    """Moves to next symbol"""
    global numRow
    numRow += 1


def createLabel():
    """Generates new unique label"""
    global labelCounter
    labelCounter += 1
    return f"IL_{labelCounter:04d}"


def emit(instruction, comment=""):
    """Emits CIL instruction"""
    global cilCode
    if comment:
        cilCode.append(f"    {instruction:<40} // {comment}")
    else:
        cilCode.append(f"    {instruction}")
    print(f"  + CIL: {instruction}")


def emitLabel(label):
    """Emits label"""
    global cilCode
    cilCode.append(f"  {label}:")
    print(f"  @ Label: {label}")


def addLocalVar(varName):
    """Registers local variable"""
    global localVars
    localVars.add(varName)


# ========== CIL CODE GENERATION ==========

def generateProgramHeader():
    """Generates program header"""
    cilCode.append("// Generated by Joovy Compiler for .NET CLR")
    cilCode.append("// Assembly: JoovyProgram")
    cilCode.append("")
    cilCode.append(".assembly JoovyProgram {}")
    cilCode.append(".assembly extern mscorlib {}")
    cilCode.append("")
    cilCode.append(".class public auto ansi JoovyProgram")
    cilCode.append("{")
    cilCode.append("  .method public static void Main() cil managed")
    cilCode.append("  {")
    cilCode.append("    .entrypoint")
    cilCode.append("    .maxstack 100")


def generateLocalVars():
    """Generates local variable declarations"""
    if localVars:
        cilCode.append("")
        cilCode.append("    // Local variables")
        cilCode.append("    .locals init (")

        varList = sorted(localVars)
        for i, var in enumerate(varList):
            if i < len(varList) - 1:
                cilCode.append(f"      [{ i}] float64 {var},")
            else:
                cilCode.append(f"      [{i}] float64 {var}")

        cilCode.append("    )")
        cilCode.append("")


def generateProgramFooter():
    """Generates program footer"""
    emit("ret", "Return from Main")
    cilCode.append("  }")
    cilCode.append("}")


# ========== TRANSLATION FUNCTIONS ==========

def translateProgram():
    """Translates entire program"""
    print("\n" + "=" * 60)
    print("TRANSLATION TO CIL")
    print("=" * 60 + "\n")

    generateProgramHeader()

    # First pass: collect all variables
    collectVariables()

    # Generate local variable declarations
    generateLocalVars()

    # Reset position
    global numRow
    numRow = 1

    # Second pass: translate code
    cilCode.append("    // Program code")

    while numRow <= len_tableOfSymb:
        numLine, lex, tok = getSymb()

        if numLine is None:
            break

        # Variable/constant declarations
        if tok == 'TYPE' or lex == 'const':
            translateDeclaration()

        # Function declaration - skip
        elif lex == 'def' and tok == 'KEYWORD':
            skipFunction()

        # Statements
        elif tok == 'IDENTIFIER' or lex in ('if', 'for', 'print', 'input', 'return') or lex == '{':
            translateStatement()

        else:
            break

    generateProgramFooter()

    print("\n" + "=" * 60)
    print("CIL CODE GENERATED")
    print("=" * 60)
    return True


def collectVariables():
    """First pass: collect all variable names"""
    global numRow
    saved_row = numRow
    numRow = 1

    while numRow <= len_tableOfSymb:
        numLine, lex, tok = getSymb()

        if numLine is None:
            break

        if tok == 'TYPE' or lex == 'const':
            nextSymb()  # Skip type/const
            if tok == 'TYPE':
                nextSymb()  # Skip type keyword

            # Get variable names
            while True:
                numLine, lex, tok = getSymb()
                if tok == 'IDENTIFIER':
                    addLocalVar(lex)
                    nextSymb()

                    # Skip initialization
                    numLine2, lex2, tok2 = getSymb()
                    if lex2 == '=':
                        nextSymb()
                        skipExpression()

                    numLine3, lex3, tok3 = getSymb()
                    if lex3 == ',':
                        nextSymb()
                    else:
                        break
                else:
                    break
        else:
            nextSymb()

    numRow = saved_row


def skipExpression():
    """Skips expression during variable collection"""
    depth = 0
    while True:
        numLine, lex, tok = getSymb()
        if lex == '(':
            depth += 1
        elif lex == ')':
            if depth == 0:
                break
            depth -= 1
        elif lex in (',', ';') and depth == 0:
            break
        elif tok == 'TYPE' or lex in ('const', 'def', 'if', 'for', 'print', 'input'):
            break
        nextSymb()


def skipFunction():
    """Skips function declaration"""
    nextSymb()  # def
    nextSymb()  # name
    nextSymb()  # (

    while True:
        numLine, lex, tok = getSymb()
        if lex == ')':
            nextSymb()
            break
        nextSymb()

    # Skip block
    depth = 1
    nextSymb()  # {

    while depth > 0:
        numLine, lex, tok = getSymb()
        if lex == '{':
            depth += 1
        elif lex == '}':
            depth -= 1
        nextSymb()


def translateDeclaration():
    """Translates variable declaration with initialization"""
    numLine, lex, tok = getSymb()

    print(f"\nTranslating declaration at line {numLine}")

    # Skip const keyword
    if lex == 'const':
        nextSymb()

    # Skip type
    nextSymb()

    # Process variable initializations
    while True:
        numLine, lex, tok = getSymb()
        varName = lex
        nextSymb()

        numLine, lex, tok = getSymb()
        if lex == '=':
            nextSymb()

            # Translate expression
            translateExpression()

            # Store to variable
            emit(f"stloc {varName}", f"Store to {varName}")

        numLine, lex, tok = getSymb()
        if lex == ',':
            nextSymb()
        else:
            break


def translateStatement():
    """Translates statement"""
    numLine, lex, tok = getSymb()

    print(f"\nTranslating statement at line {numLine}")

    # Assignment
    if tok == 'IDENTIFIER':
        saved_row = numRow
        nextSymb()
        numLine2, lex2, tok2 = getSymb()
        numRow = saved_row

        if lex2 == '=' and tok2 == 'ASSIGN_OP':
            translateAssignment()
        elif lex2 == '(':
            # Function call - skip
            skipFunctionCall()

    # If statement
    elif lex == 'if':
        translateIf()

    # Print
    elif lex == 'print':
        translatePrint()

    # Input
    elif lex == 'input':
        translateInput()

    # Block
    elif lex == '{':
        translateBlock()


def translateAssignment():
    """Translates assignment"""
    numLine, lex, tok = getSymb()
    varName = lex
    nextSymb()

    nextSymb()  # =

    translateExpression()

    emit(f"stloc {varName}", f"Store to {varName}")


def translateIf():
    """Translates if statement"""
    print("  Translating if statement")

    nextSymb()  # if
    nextSymb()  # (

    translateExpression()

    nextSymb()  # )

    labelElse = createLabel()
    labelEnd = createLabel()

    # If false, branch to else
    emit(f"brfalse {labelElse}", "Jump to else if false")

    # Then block
    translateBlock()

    # Check for else
    numLine, lex, tok = getSymb()
    if lex == 'else':
        emit(f"br {labelEnd}", "Jump to end")
        emitLabel(labelElse)

        nextSymb()  # else
        translateBlock()

        emitLabel(labelEnd)
    else:
        emitLabel(labelElse)


def translatePrint():
    """Translates print statement"""
    print("  Translating print")

    nextSymb()  # print
    nextSymb()  # (

    # Count expressions
    expressions = []

    numLine, lex, tok = getSymb()
    if lex != ')':
        translateExpression()
        expressions.append(True)

        while True:
            numLine, lex, tok = getSymb()
            if lex == ',':
                nextSymb()
                translateExpression()
                expressions.append(True)
            else:
                break

    nextSymb()  # )

    # Print each value (they're on stack in reverse order)
    # For now, just print as float64
    for _ in expressions:
        emit("call void [mscorlib]System.Console::WriteLine(float64)")


def translateInput():
    """Translates input statement"""
    print("  Translating input")

    nextSymb()  # input
    nextSymb()  # (

    numLine, lex, tok = getSymb()
    varName = lex
    nextSymb()

    nextSymb()  # )

    # Read line and parse
    emit("call string [mscorlib]System.Console::ReadLine()")
    emit("call float64 [mscorlib]System.Double::Parse(string)")
    emit(f"stloc {varName}", f"Store input to {varName}")


def translateBlock():
    """Translates block"""
    nextSymb()  # {

    while True:
        numLine, lex, tok = getSymb()
        if lex == '}':
            nextSymb()
            break
        translateStatement()


def skipFunctionCall():
    """Skips function call"""
    nextSymb()  # name
    nextSymb()  # (

    depth = 1
    while depth > 0:
        numLine, lex, tok = getSymb()
        if lex == '(':
            depth += 1
        elif lex == ')':
            depth -= 1
        nextSymb()


def translateExpression():
    """Translates expression"""
    translateCompareExpr()


def translateCompareExpr():
    """Translates comparison expression"""
    translateArithExpr()

    numLine, lex, tok = getSymb()
    if tok == 'COMPARE_OP':
        op = lex
        nextSymb()
        translateArithExpr()

        # CIL comparison instructions
        if op == '==':
            emit("ceq", "Compare equal")
        elif op == '>':
            emit("cgt", "Compare greater than")
        elif op == '<':
            emit("clt", "Compare less than")
        elif op == '>=':
            # a >= b is NOT (a < b)
            emit("clt", "Compare less than")
            emit("ldc.i4.0")
            emit("ceq", "Invert")
        elif op == '<=':
            # a <= b is NOT (a > b)
            emit("cgt", "Compare greater than")
            emit("ldc.i4.0")
            emit("ceq", "Invert")
        elif op == '!=':
            emit("ceq", "Compare equal")
            emit("ldc.i4.0")
            emit("ceq", "Invert")


def translateArithExpr():
    """Translates arithmetic expression"""
    translateTerm()

    while True:
        numLine, lex, tok = getSymb()
        if tok == 'ADD_OP':
            op = lex
            nextSymb()
            translateTerm()

            if op == '+':
                emit("add", "Addition")
            else:
                emit("sub", "Subtraction")
        else:
            break


def translateTerm():
    """Translates term"""
    translatePower()

    while True:
        numLine, lex, tok = getSymb()
        if tok == 'MULT_OP':
            op = lex
            nextSymb()
            translatePower()

            if op == '*':
                emit("mul", "Multiplication")
            else:
                emit("div", "Division")
        else:
            break


def translatePower():
    """Translates power expression"""
    translateFactor()

    while True:
        numLine, lex, tok = getSymb()
        if lex == '^' and tok == 'POWER_OP':
            nextSymb()
            translateFactor()

            # Power operation (use Math.Pow)
            emit("call float64 [mscorlib]System.Math::Pow(float64, float64)")
        else:
            break


def translateFactor():
    """Translates factor"""
    numLine, lex, tok = getSymb()

    # Unary operator
    unaryOp = None
    if tok == 'ADD_OP' and lex in ('+', '-'):
        unaryOp = lex
        nextSymb()

    translatePrimary()

    if unaryOp == '-':
        emit("neg", "Negate")


def translatePrimary():
    """Translates primary expression"""
    numLine, lex, tok = getSymb()

    # Constant
    if tok == 'INT':
        emit(f"ldc.r8 {lex}", f"Load constant {lex}")
        nextSymb()

    elif tok == 'FLOAT':
        emit(f"ldc.r8 {lex}", f"Load constant {lex}")
        nextSymb()

    elif tok == 'BOOL':
        value = "1" if lex == 'true' else "0"
        emit(f"ldc.i4 {value}", f"Load boolean {lex}")
        nextSymb()

    elif tok == 'STRING':
        # Remove quotes
        string_value = lex.strip('"')
        emit(f'ldstr "{string_value}"', f"Load string")
        nextSymb()

    # Variable
    elif tok == 'IDENTIFIER':
        varName = lex
        nextSymb()

        # Check for function call
        numLine2, lex2, tok2 = getSymb()
        if lex2 == '(':
            # Function call - skip for now
            skipFunctionCall()
        else:
            emit(f"ldloc {varName}", f"Load {varName}")

    # Parenthesized expression
    elif lex == '(':
        nextSymb()
        translateExpression()
        nextSymb()  # )


# ========== MAIN TRANSLATION FUNCTION ==========

def translate(table_of_symb):
    """Main translation function"""
    global tableOfSymb, numRow, len_tableOfSymb, cilCode, localVars, labelCounter

    # Initialize
    tableOfSymb = table_of_symb
    numRow = 1
    len_tableOfSymb = len(tableOfSymb)
    cilCode = []
    localVars = set()
    labelCounter = 0

    # Translate
    try:
        translateProgram()
        return True, cilCode
    except Exception as e:
        print(f"\nTranslation ERROR: {e}")
        import traceback
        traceback.print_exc()
        return False, []


def start(file_path):
    """Runs complete analysis and translation"""
    # Run lexer
    lex_success = lex_start(file_path)

    if not lex_success or g.errorCount > 0:
        print("\n✗ Lexical analysis failed. Translation not possible.")
        return False, []

    # Translate
    success, cil_code = translate(g.tableOfSymb)

    if success:
        print("\n" + "=" * 60)
        print("✓ CIL Translation completed successfully")
        print("=" * 60)

    return success, cil_code
